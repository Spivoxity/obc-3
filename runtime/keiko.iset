#
# keiko.iset
# 
# This file is part of the Oxford Oberon-2 compiler
# Copyright (c) 2006--2016 J. M. Spivey
# All rights reserved
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice,
#    this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright notice,
#    this list of conditions and the following disclaimer in the documentation
#    and/or other materials provided with the distribution.
# 3. The name of the author may not be used to endorse or promote products
#    derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
# OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
# IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
# OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
# WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
# OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
# ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#

# CONSTANTS

inst PUSH {[-1,10,1] 1 2} V.i { $a }            { push_con(arg1) }
inst LDKW {1 2} V.i { const($a).i }             { konst(V_KONW, INT, arg1, 1) }
inst LDKF {1 2} V.f { const($a).f }             { konst(V_KONW, FLO, arg1, 1) }


# ADDRESSING OPERATORS

# Push address of local
# LOCAL n :: --> bp+n
inst LOCAL {[0] 1 2} V.x { local($a) }          { local(arg1) }

# Compute indexed address
# INDEXs :: a, b --> a + s * b
inst OFFSET 0 B.x   { pointer($1) + $2.i }      { add_offset() }
inst INDEXS 0 B.x   { index($1, $2, 1) }        {= PUSH 1, LSL, OFFSET }
inst INDEXW 0 B.x   { index($1, $2, 2) }        {= PUSH 2, LSL, OFFSET }
inst INDEXD 0 B.x   { index($1, $2, 3) }        {= PUSH 3, LSL, OFFSET }


# LOADS AND STORES

# Load/store from address
# LOADs :: a --> mem_s[a]
# STOREs :: a, b --> []; mem_s[b] := a
inst LOADW 0 M.i    { load($1, int) }           { deref(V_MEMW, INT, 1) }
inst LOADS 0 M.i    { load($1, short) }         { deref(V_MEMS, INT, 1) }
inst LOADC 0 M.i    { load($1, uchar) }         { deref(V_MEMC, INT, 1) }
inst LOADF 0 M.f    { load($1, float) }         { deref(V_MEMW, FLO, 1) }
inst STOREW 0 S2    { store($1.i, $2, int) }    { store(V_MEMW, 1) }
inst STORES 0 S2    { store($1.i, $2, short) }  { store(V_MEMS, 1) }
inst STOREC 0 S2    { store($1.i, $2, uchar) }  { store(V_MEMC, 1) }
inst STOREF 0 S2    { store($1.f, $2, float) }  { store(V_MEMW, 1) }

# Load/store local
# LDLs n :: --> mem_s[bp+n]
# STLs n :: a --> []; mem_s[bp+n] := a
inst LDLW {[-24,-4,4] [12,32,4] 1 2} V.i \
                    { ldl($a, int)}             {= LOCAL $a, LOADW }
inst LDLS {1 2} V.i { ldl($a, short) }          {= LOCAL $a, LOADS }
inst LDLC {1 2} V.i { ldl($a, uchar) }          {= LOCAL $a, LOADC }
inst LDLF {1 2} V.f { ldl($a, float) }          {= LOCAL $a, LOADF }
inst STLW {[-24,-4,4] [12,32,4] 1 2} S1 \
                    { stl($a, $1.i, int) }      {= LOCAL $a, STOREW }
inst STLS {1 2} S1  { stl($a, $1.i, short) }    {= LOCAL $a, STORES }
inst STLC {1 2} S1  { stl($a, $1.i, uchar) }    {= LOCAL $a, STOREC }
inst STLF {1 2} S1  { stl($a, $1.f, float) }    {= LOCAL $a, STOREF }

# Load/store global
# LDGs n :: --> mem_s[const(n)]
# STGs n :: a --> []; mem_s[const(n)] := a
inst LDGW {K L} V.i { ldg($a, int) }            {= LDKW $a, LOADW }
inst LDGS {K L} V.i { ldg($a, short) }          {= LDKW $a, LOADS }
inst LDGC {K L} V.i { ldg($a, uchar) }          {= LDKW $a, LOADC }
inst LDGF {K L} V.f { ldg($a, float) }          {= LDKW $a, LOADF }
inst STGW {K L} S1  { stg($a, $1.i, int) }      {= LDKW $a, STOREW }
inst STGS {K L} S1  { stg($a, $1.i, short) }    {= LDKW $a, STORES }
inst STGC {K L} S1  { stg($a, $1.i, uchar) }    {= LDKW $a, STOREC }
inst STGF {K L} S1  { stg($a, $1.f, float) }    {= LDKW $a, STOREF }

# Indexed load/store
# LDNs n :: a -> mem_s[a+n]
# STNs n :: a, b -> []; mem_s[b+n] := a
inst LDNW {[-16,32,4] 1 2} M.i \
                    { ldn($a, $1) }             {= PUSH $a, OFFSET, LOADW }
inst STNW {[-16,32,4] 1 2} S2 \
                    { stn($a, $1.i, $2) }       {= PUSH $a, OFFSET, STOREW }

# Double indexed load/store
# LDIs :: a, b --> mem_s[a+s*b]
# STIs :: a, b, c --> []; mem_s[b+s*c] := a
inst LDIW 0 B.i     { ldi($1, $2, int) }        {= INDEXW, LOADW }
inst LDIS 0 B.i     { ldi($1, $2, short) }      {= INDEXS, LOADS }
inst LDIC 0 B.i     { ldi($1, $2, uchar) }      {= OFFSET, LOADC }
inst LDIF 0 B.f     { ldi($1, $2, float) }      {= INDEXW, LOADF }
inst STIW 0 S3      { sti($1.i, $2, $3, int) }  {= INDEXW, STOREW }
inst STIS 0 S3      { sti($1.i, $2, $3, short) }  {= INDEXS, STORES }
inst STIC 0 S3      { sti($1.i, $2, $3, uchar) }  {= OFFSET, STOREC }
inst STIF 0 S3      { sti($1.f, $2, $3, float) }  {= INDEXW, STOREF }

# If the argument of any of the above instructions is so large that it
# does not fit in two bytes, then it's the job of the compiler to find
# an equivalent sequence using LDKW that achieves the same effect:
# for example, LDLW n --> LDKW [n] / LOADW

# Loads and stores for doubles
inst LOADD 0 M.dp   { getdbl(valptr($1)) }      { deref(V_MEMQ, FLO, 2) }
inst STORED 0 S2dp  { putdbl(valptr($2), $1.d) } { store(V_MEMQ, 2) }
inst LDKD {1 2} V.d { getdbl(&const($a)) }      { konst(V_KONQ, FLO, arg1, 2) }

inst LOADQ 0 M.qp   { getlong(valptr($1)) }     { loadq() }
inst STOREQ 0 S2qp  { putlong(valptr($2), $1.q) } { store(V_MEMQ, 2) }
inst LDKQ {1 2} V.q { getlong(&const($a)) }     { konst(V_KONQ, INT, arg1, 2) }
    
equiv LDID 0        { INDEXD, LOADD }
equiv STID 0        { INDEXD, STORED }
equiv LDLD 1        { LOCAL $a, LOADD }
equiv STLD 1        { LOCAL $a, STORED }
equiv LDGD K        { LDKW $a, LOADD }
equiv STGD K        { LDKW $a, STORED }

equiv LDIQ 0        { INDEXD, LOADQ }
equiv STIQ 0        { INDEXD, STOREQ }
equiv LDLQ 1        { LOCAL $a, LOADQ }
equiv STLQ 1        { LOCAL $a, STOREQ }
equiv LDGQ K        { LDKW $a, LOADQ }
equiv STGQ K        { LDKW $a, STOREQ }

# ASSORTED INSTRUCTIONS

inst INCL 1 S0      { indir(local($a), int)++ } {= LDLW $a, INC, STLW $a }
equiv INCL 2        { LDLW $a, INC, STLW $a }

inst DECL 1 S0      {indir(local($a), int)--}   {= LDLW $a, DEC, STLW $a }
equiv DECL 2        { LDLW $a, DEC, STLW $a }

inst DUP {[0,2,1]} S0 \
                    {dup($a, $s)}
inst SWAP 0 S0      {swap($s)}
inst POP 1 S0       {sp += $a}                  {pop(arg1)}


# INTEGER OPERATORS

inst PLUS 0 B.i     { $1.i + $2.i }             { ibinop(ADD) }
inst MINUS 0 B.i    { $1.i - $2.i }             { ibinop(SUB) }
inst TIMES 0 B.i    { $1.i * $2.i }             { multiply() }
inst UMINUS 0 M.i   { - $1.i }                  { imonop(NEG) }

inst AND 0 B.i      { $1.i && $2.i }            { ibinop(AND) }
inst OR 0 B.i       { $1.i || $2.i }            { ibinop(OR) }
inst NOT 0 M.i      { ! $1.i }                  { push_con(1); ibinop(XOR) }
inst INC 0 M.i      { $1.i + 1 }                {= PUSH 1, PLUS }
inst DEC 0 M.i      { $1.i - 1 }                {= PUSH 1, MINUS }
inst BITAND 0 B.i   { $1.i & $2.i }             { ibinop(AND) }
inst BITOR 0 B.i    { $1.i | $2.i }             { ibinop(OR) }
inst BITXOR 0 B.i   { $1.i ^ $2.i }             { ibinop(XOR) }
inst BITNOT 0 M.i   { ~ $1.i }                  { imonop(NOT) }

inst LSL 0 B.i      { $1.i << $2.i }            { lsl() }
inst LSR 0 B.i      { (unsigned) $1.i>>$2.i }   { ibinop(RSHu) }
inst ASR 0 B.i      { $1.i >> $2.i }            { ibinop(RSH) }
inst ROR 0 B.i      { ror($1.i, $2.i) }         { ibinop(ROR) }

inst DIV 0 T2       { int_div(sp) }             { callout(int_div, 2, INT, 1) }
inst MOD 0 T2       { int_mod(sp) }             { callout(int_mod, 2, INT, 1) }

inst EQ 0 B.i       { $1.i == $2.i }            { compare(EQ) }
inst LT 0 B.i       { $1.i < $2.i }             { compare(LT) }
inst GT 0 B.i       { $1.i > $2.i }             { compare(GT) }
inst LEQ 0 B.i      { $1.i <= $2.i }            { compare(LE) }
inst GEQ 0 B.i      { $1.i >= $2.i }            { compare(GE) }
inst NEQ 0 B.i      { $1.i != $2.i }            { compare(NE) }

inst JEQ {S R} S2   { if ($1.i == $2.i) jump($a) } { condj(&j_eq, arg1) }
inst JLT {S R} S2   { if ($1.i < $2.i) jump($a) }  { condj(&j_lt, arg1) }
inst JGT {S R} S2   { if ($1.i > $2.i) jump($a) }  { condj(&j_gt, arg1) }
inst JLEQ {S R} S2  { if ($1.i <= $2.i) jump($a) } { condj(&j_le, arg1) }
inst JGEQ {S R} S2  { if ($1.i >= $2.i) jump($a) } { condj(&j_ge, arg1) }
inst JNEQ {S R} S2  { if ($1.i != $2.i) jump($a) } { condj(&j_ne, arg1) }

inst JLTZ S S1      { if ($1.i < 0) jump($a) }  {= PUSH 0, JLT $a }
inst JGTZ S S1      { if ($1.i > 0) jump($a) }  {= PUSH 0, JGT $a }
inst JLEQZ S S1     { if ($1.i <= 0) jump($a) } {= PUSH 0, JLEQ $a }
inst JGEQZ S S1     { if ($1.i >= 0) jump($a) } {= PUSH 0, JGEQ $a }

equiv JLTZ R        { PUSH 0, JLT $a }
equiv JGTZ R        { PUSH 0, JGT $a }
equiv JLEQZ R       { PUSH 0, JLEQ $a }
equiv JGEQZ R       { PUSH 0, JGEQ $a }

inst JNEQZ {S R} S1 { if ($1.i != 0) jump($a) } {= PUSH 0, JNEQ $a }
inst JEQZ {S R} S1  { if ($1.i == 0) jump($a) } {= PUSH 0, JEQ $a }
inst JUMP {S R} S0  { jump($a) }                { jump(arg1) }


# LONGINT OPERATORS

inst QPLUS 0 B.q    { $1.q + $2.q }             { qbinop(ADDq) }
inst QMINUS 0 B.q   { $1.q - $2.q }             { qbinop(SUBq) }
inst QTIMES 0 B.q   { $1.q * $2.q }             { qbinop(MULq) }
inst QUMINUS 0 M.q  { - $1.q }                  { qmonop(NEGq) }
inst QDIV 0 T2q     { long_div(sp) }            { callout(long_div, 2, INT, 2) }
inst QMOD 0 T2q     { long_mod(sp) }            { callout(long_mod, 2, INT, 2) }

equiv QINC 0        { PUSH 1, CONVNQ, QPLUS }
equiv QDEC 0        { PUSH 1, CONVNQ, QMINUS }

inst QCMP 0 B.iqq   { lcmp($1.q, $2.q) }

equiv QEQ 0         { QCMP, PUSH 0, EQ }
equiv QLT 0         { QCMP, PUSH 0, LT }
equiv QGT 0         { QCMP, PUSH 0, GT }
equiv QLEQ 0        { QCMP, PUSH 0, LEQ }
equiv QGEQ 0        { QCMP, PUSH 0, GEQ }
equiv QNEQ 0        { QCMP, PUSH 0, NEQ }

equiv QJEQ R        { QCMP, JEQZ $a }
equiv QJLT R        { QCMP, JLTZ $a }
equiv QJGT R        { QCMP, JGTZ $a }
equiv QJLEQ R       { QCMP, JLEQZ $a }
equiv QJGEQ R       { QCMP, JGEQZ $a }
equiv QJNEQ R       { QCMP, JNEQZ $a }


# CASE STATEMENTS

inst JCASE 1 S1 {
     if ((unsigned) $1.i < (unsigned) $a)
          pc0 = pc + 2*$1.i, jump(get2(pc0)); else pc += 2*$a;
}
zinst CASEL R

inst JRANGE {S R} S3 {
     if ($1.i >= $2.i && $1.i <= $3.i) jump($a);
}

# The "T2" means take two arguments, but leave one of them on the stack
inst TESTGEQ {S R} T2 {
     if ($1.i >= $2.i) jump($a)
}


# FLOATING-POINT OPERATORS

inst FPLUS 0 B.f    { $1.f + $2.f }             { fbinop(ADDf) }
inst FMINUS 0 B.f   { $1.f - $2.f }             { fbinop(SUBf) }
inst FTIMES 0 B.f   { $1.f * $2.f }             { fbinop(MULf) }
inst FDIV 0 B.f     { $1.f / $2.f }             { fbinop(DIVf) }
inst FUMINUS 0 M.f  { - $1.f }                  { fmonop(NEGf) }

inst FCMPL 0 B.i    { fcmpl($1.f, $2.f) }       { fcompare(FCMPL) }
inst FCMPG 0 B.i    { fcmpg($1.f, $2.f) }       { fcompare(FCMPG) }

equiv FEQ 0         { FCMPL, PUSH 0, EQ }
equiv FNEQ 0        { FCMPL, PUSH 0, NEQ }
equiv FLT 0         { FCMPG, PUSH 0, LT }
equiv FGT 0         { FCMPL, PUSH 0, GT }
equiv FLEQ 0        { FCMPG, PUSH 0, LEQ }
equiv FGEQ 0        { FCMPL, PUSH 0, GEQ }

# The floating-point conditional jumps are just shorthand for a
# comparison and an integer jump.  This saves valuable opcodes for more
# important functions.
equiv FJEQ R        { FCMPL, JEQZ $a }
equiv FJNEQ R       { FCMPL, JNEQZ $a }
equiv FJLT R        { FCMPG, JLTZ $a }
equiv FJGT R        { FCMPL, JGTZ $a }
equiv FJLEQ R       { FCMPG, JLEQZ $a }
equiv FJGEQ R       { FCMPL, JGEQZ $a }
equiv FJNLT R       { FCMPG, JGEQZ $a }
equiv FJNGT R       { FCMPL, JLEQZ $a }
equiv FJNLEQ R      { FCMPG, JGTZ $a }
equiv FJNGEQ R      { FCMPL, JLTZ $a }


# DOUBLE-PRECISION OPERATORS

inst DPLUS 0 B.d    { $1.d + $2.d }             { dbinop(ADDd) }
inst DMINUS 0 B.d   { $1.d - $2.d }             { dbinop(SUBd) }
inst DTIMES 0 B.d   { $1.d * $2.d }             { dbinop(MULd) }
inst DDIV 0 B.d     { $1.d / $2.d }             { dbinop(DIVd) }
inst DUMINUS 0 M.d  { - $1.d }                  { dmonop(NEGd) }

inst DCMPL 0 B.idd  { fcmpl($1.d, $2.d) }       { fcompare(DCMPL) }
inst DCMPG 0 B.idd  { fcmpg($1.d, $2.d) }       { fcompare(DCMPG) }

equiv DEQ 0         { DCMPL, PUSH 0, EQ }
equiv DNEQ 0        { DCMPL, PUSH 0, NEQ }
equiv DLT 0         { DCMPG, PUSH 0, LT }
equiv DGT 0         { DCMPL, PUSH 0, GT }
equiv DLEQ 0        { DCMPG, PUSH 0, LE }
equiv DGEQ 0        { DCMPL, PUSH 0, GE }

equiv DJEQ R        { DCMPL, JEQZ $a }
equiv DJNEQ R       { DCMPL, JNEQZ $a }
equiv DJLT R        { DCMPG, JLTZ $a }
equiv DJGT R        { DCMPL, JGTZ $a }
equiv DJLEQ R       { DCMPG, JLEQZ $a }
equiv DJGEQ R       { DCMPL, JGEQZ $a }
equiv DJNLT R       { DCMPG, JGEQZ $a }
equiv DJNGT R       { DCMPL, JLEQZ $a }
equiv DJNLEQ R      { DCMPG, JGTZ $a }
equiv DJNGEQ R      { DCMPL, JLTZ $a }


# CONVERSIONS

inst CONVNF 0 M.f   { flo_conv($1.i) }          { fdmonop(CONVif, INT, FLO, 1) }
inst CONVND 0 M.di  { flo_conv($1.i) }          { fdmonop(CONVid, INT, FLO, 2) }
inst CONVFN 0 M.i   { (int) $1.f }              { fdmonop(CONVfi, FLO, INT, 1) }
inst CONVDN 0 M.id  { (int) $1.d }              { fdmonop(CONVdi, FLO, INT, 1) }
inst CONVFD 0 M.df  { $1.f }                    { fdmonop(CONVfd, FLO, FLO, 2) }
inst CONVDF 0 M.fd  { (float) $1.d }            { fdmonop(CONVdf, FLO, FLO, 1) }
inst CONVNC 0 M.i   { $1.i & 0xff }             { push_con(0xff); ibinop(AND) }
inst CONVNS 0 M.i   { (short) $1.i }            { gmonop(CONVis, INT, INT, 1) }
inst CONVNQ 0 M.qi  { $1.i }
inst CONVQN 0 M.iq  { (int) $1.q }
inst CONVQD 0 M.dq  { flo_convq($1.q) }         { callout(long_flo, 1, FLO, 2) }


# RUN-TIME CHECKS

# The operand of these checks is the line number to show in the error
# message.  God forbid people should make source files containing
# more than 65536 lines

inst BOUND 2 T2 \
    { if ((unsigned) $1.i > (unsigned) $2.i) error(E_BOUND, $a) }
inst NCHECK 2 T1 \
    { if (pointer($1) == NULL) error(E_NULL, $a) }
inst GCHECK 2 S1  \
    { if (valptr($1) != NULL) error(E_GLOB, $a) }
inst ZCHECK 2 T1 \
    { if ($1.i == 0) error(E_DIV, $a) }
inst FZCHECK 2 T1 \
    { if ($1.f == 0.0) error(E_FDIV, $a) }
inst DZCHECK 2 T1d \
    { if ($1.d == 0.0) error(E_FDIV, $a) }
inst QZCHECK 2 T1q \
    { if ($1.q == 0) error(E_DIV, $a) }
inst ERROR 12 S0    { error($a, $b) }
equiv EASSERT 2     { RESULTW, ERROR E_ASSERT $a }


# MORE BITS AND PIECES

# ALIGNs instructions are used on big-endian machines like the SPARC
# to ensure that CHAR and SHORT parameters appear at the right address.
inst ALIGNC 0 M.i   { alignx($1.i, 8) }
inst ALIGNS 0 M.i   { alignx($1.i, 16) }

# FIXCOPY copies a fixed number of bytes; it is used for structure
# assignment and also for value parameters of (fixed) array or record type. */
inst FIXCOPY 0 S3 {
    prof_charge($3.i/4);
    memcpy(pointer($1), pointer($2), $3.i);
}

# FLEXCOPY expects to find on the stack the address of a flex array parameter 
# and a size in bytes; it copies the parameter to dynamic local space, 
# then overwrites the parameter with the new address.
inst FLEXCOPY 0 S0 {
     value *d = (value *) pointer(sp[1]); int size = sp[0].i;           
     int sizew = (size+3)/4; prof_charge(sizew);                        
     sp -= sizew - 2;                                                   
     if ((uchar *) sp < stack + SLIMIT) error(E_STACK, 0);              
     memcpy(sp, pointer(d[0]), size);                                   
     d[0].a = address(sp);
}

# In the interpreter, the CALLW and CALLD instructions are implemented as 
# two operations, an ordinary CALL followed by a SLIDE; the return address 
# of the called routine points to the SLIDE instruction, which is 
# responsible for copying the result.
equiv CALL 1        { JPROC, SLIDE $a }
equiv CALLW 1       { JPROC, SLIDEW $a }
equiv CALLQ 1       { JPROC, SLIDEQ $a }
equiv CALLF 1       { JPROC, SLIDEF $a }
equiv CALLD 1       { JPROC, SLIDED $a }

inst LINK 0 S1      { statlink = valptr($1) }
inst SAVELINK 0 S0  { bp[SL].a = address(statlink) }

inst JPROC 0 S0 {
     value *p = valptr(sp[0]);
     sp -= HEAD-1; sp[BP].a = address(bp); sp[PC].a = address(pc);

     if (interpreted(p)) {
          cp = p; pc = pointer(cp[CP_CODE]);
          goto enter;
     }

#ifdef PROFILE
     /* Calling a native-code routine */
    prof_enter(p, ticks, PROF_PRIM);
    ticks = 0;
#endif
#ifdef OBXDEB
    prim_bp = sp;
#endif
    primcall(p, sp);
#ifdef OBXDEB
    prim_bp = NULL;
#endif
}

inst SLIDE 1 S0 \
    { slide($a) } \
    { proc_call(pc, arg1, 0, 0, 0) }
inst SLIDEW 1 S0 \
    { slide($a); sp--; sp[0].i = ob_res.i } \
    { proc_call(pc, arg1, INT, V_MEMW, 1) }
inst SLIDEF 1 S0 \
    { slide($a); sp--; sp[0].f = ob_res.f } \
    { proc_call(pc, arg1, FLO, V_MEMW, 1) }
inst SLIDED 1 S0 \
    { slide($a); sp -= 2; putdbl(&sp[0], getdbl(&ob_res)) } \
    { proc_call(pc, arg1, FLO, V_MEMQ, 2) }
inst SLIDEQ 1 S0 \
    { slide($a); sp -= 2; putlong(&sp[0], getlong(&ob_res)) } \
    { proc_call(pc, arg1, INT, V_MEMQ, 2) }
    
equiv RETURNW 0     { RESULTW, RETURN }
equiv RETURNF 0     { RESULTF, RETURN }
equiv RETURND 0     { RESULTD, RETURN }
equiv RETURNQ 0     { RESULTQ, RETURN }

inst RESULTW 0 S1   { ob_res = $1 }             { result(V_MEMW, 1) }
inst RESULTF 0 S1   { ob_res.f = $1.f }         { result(V_MEMW, 1) }
inst RESULTQ 0 S1q  { putlong(&ob_res, $1.q) }  { result(V_MEMQ, 2) }
inst RESULTD 0 S1d  { putdbl(&ob_res, $1.d) }   { result(V_MEMQ, 2) }

inst RETURN 0 S0 {
     if (bp == base) {
          level--;
#ifdef PROFILE
          prof_exit(NULL, ticks);
#endif
          return;
     }

     sp = bp; pc = pointer(sp[PC]); bp = valptr(sp[BP]); cp = valptr(bp[CP]);
     do_find_proc;
#ifdef PROFILE
     prof_exit(cp, ticks);
     ticks = 0;
#endif
     cond_break();
}

inst LNUM 2 S0 {
#ifdef PROFILE
     if (lflag) {
          static module m = NULL; /* Cache most recent module */
          ticks--;
          if (m == NULL || cp < (value *) m->m_addr 
                || cp >= (value *) (m->m_addr + m->m_length)) {
               m = find_module(cp);
         }
          m->m_lcount[$a-1]++; 
     }
#endif
#ifdef OBXDEB
     if (intflag)
          debug_break(cp, bp, pc0, "interrupt");
     else if (one_shot) 
          debug_break(cp, bp, pc0, "line");
#endif
}

inst BREAK 2 S0 {
#ifdef OBXDEB
     debug_break(cp, bp, pc0, "break");
#endif
}

if {[info exists SPECIALS]} {

# SPECIALS FOR COMPILERS COURSE

inst CASEJUMP 1 S1  { casejump($1.i, $a) }
zinst CASEARM 2R

inst PACK 0 B.i     { pack(valptr($2), pointer($1)) }
inst UNPACK 0 S0    { sp--; sp[0].a = address(getcode(sp[1].i)); 
                      sp[1].a = address(getenvt(sp[1].i)) }
}

# DIRECTIVES

dir CONST ?
dir FCONST ?
dir DCONST ?
dir QCONST ?
dir GLOBAL ?
dir LABEL ?
dir PROC ????
dir END 0
dir PRIMDEF ???
dir DEFINE ?
dir STRING ?
dir GLOVAR ??
dir WORD ?
dir MODULE ???
dir ENDHDR 0
dir IMPORT ??
dir STKMAP ?
dir LINE ?

if {[info exists SPECIALS]} {
    dir PCALL ?
    dir PCALLW ?
}
